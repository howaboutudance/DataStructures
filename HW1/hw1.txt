HW1 Winter 
Data Structures
Michelle Bergin

4.19 Show the result of inserting 2, 1, 4, 5, 9, 3, 6, 7 into an initially empty AVL tree.

                                     2
                                  /     \
                                1         4
                                             \
                                               5

                                     2
                                  /     \
                                1         5
                                        /   \
                                       4     9


                                     4
                                  /     \
                                2         5
                              /   \         \
                            1       3         9


                                     4
                                  /     \
                                2         6
                              /   \     /   \
                            1      3   5     9


                                     4
                                  /     \
                                2         6
                              /   \     /   \
                            1      3   5     9
                                            /
                                           7

4.26 Write the functions to perform the double rotation without the inefficiency of doing two single rotations.

	help

4.27 Show the result of accessing the keys 3, 9, 1, 5 in order in the splay tree in Figure 4.76.

                                     10
                                   /    \
                                 4        11
                               /   \         \
                             2       6         12
                           /  \     /  \          \
                         1     3   5     8          13
                                       /   \
                                     7       9


Search for '3'                       10
Step one                           /    \
                                 3        11
                               /   \         \
                             2       4         12
                           /           \          \ 
                         1               6          13
                                       /   \
                                      5     8
                                          /   \
                                        7       9

Search for '3'                        3
Step two                            /   \
                                  4       10
                                /   \       \
                              2      6        11
                            /      /   \        \
                          1      5       8        12
                                       /   \        \
                                     7       9        13

Search for '9'                        3
Step one                            /   \
                                  4       10
                                /   \       \
                              2      6        11
                            /      /   \        \
                          1      5       9        12
                                       /            \
                                     8                13
                                   /
                                 7
 
Search for '9'                        3
Step two                            /   \
                                  4       10 
                                /   \       \
                              2      9        11
                            /      /           \
                          1      6               12
                               /   \               \
                             5       8              13
                                   /
                                 7

Search for '9'                        3
Step three                          /   \
                                  9       10
                                /           \
                              4               11
                            /   \               \
                          2      6               12
                        /      /   \               \
                      1      5      8               13
                                   /
                                  7

Search for '9'                        9
step four                           /   \
                                  3       10
                                   \        \
                                    4        11
                                  /   \        \
                                2      6        12
                              /      /   \        \
                            1      5      8        13
                                         /
                                       7
Before I continue, let's see that this is done right.. :/

4.31 Write efficient functions that take only a pointer to the root of a binary tree, T, and compute 
a. the number of nodes in T 
b. the number of leaves in T 
c. the number of full nodes in T 
What is the running time of your routines?

+=====+
|  a  |
+=====+

        int numNodes(){
            return numNodes(root);
        }
        int numNodes(bstNode *n){
            int count = 1;
            if(n->left != NULL){
                count += numNodes(n->left);
            }
            if(n->right != NULL){
                count += numNodes(n->right);
            }
            return count;
        }

+=====+
|  b  |
+=====+

        }
        int leaves(){
            return leaves(root);
        }
        int leaves(bstNode *n){
            if(n == NULL)
                return 0;
            if(n->left == NULL && n->right == NULL)
                return 1;
            else
                return leaves(n->left) + leaves(n->right);
        }

+=====+
|  c  |
+=====+

	help


4.43 
Show how the tree in Figure 4.77 is represented using a child/sibling link implementation.

Each Node has a link to it's parent. They each have their data. They each have a linked list or Array of children. That way each child can be accessed via the array and each child can find it's parent. For example A and M each have 3 children. 


4.45
Two binary trees are similar if they are both empty or both nonempty and have similar left and right subtrees. Write a function to decide whether two binary trees are similar. What is the running time of your function?

Something like this?

 bool same(bst &t){
 	return same(t->root,root);
 }
 bool same(bstNode *i, bstNode *o){
 	if(i == NULL || o == NULL)
		;
	if(i->data != o->data)
		return false;
	else {
		same(i->left, o->left);
		same(i->right, o->right);
	}
	return true;
	
 }
